# Introduction
`beiwedata` is a set of Python scripts designed to help munge, analyze, and manipulate data generated by the Beiwe application. 

# Table of Contents
- [Usage](#usage)
- [Data overview](#data-overview)
    - [Timestamps](#timestamps)
    - [Accelerometer](#accelerometer-data)
    - [Bluetooth](#bluetooth)
    - [Phone calls](#phone-calls)
    - [GPS](#gps)
    - [IDs](#ids)
    - [Application log files](#beiwe-logs)
    - [Power state](#power-state)
    - [Survey answers](#survey-answers)
    - [Survey timings](#survey-timings)
    - [Text messages](#text-messages)
    - [Voice memos](#voice-memos)
    - [WiFi logs](#wifi)
- [Known data issues](#known-data-issues)
- [Functions](#functions)
- [Example plots](#example-plots)



# Usage
`from beiwedata import *` is the standard way to import and this document will assume `beiwedata` has been imported to the top level. If you `import as`, please adjust the usage examples accordingly.

# Data overview
There are a total of 12 types of files generated by the `beiwe` app. Files are stored as comma-separated values (`csv`) files and **every** file contains column headers (including empty files). Empty files are created when the application is activated and data is being collected, but there is no data to collect. For example, during a "WiFi" check the application will activate, check for WiFi signals, and record them. During this time, it may also check to see if there is any new Bluetooth or call/text information to gather. If no new information exists, it will create the file with the headers, but no other rows.

\#|Data stream|File prefix|\# Col
:-:|-----------|-----------|:---:
1|Accelerometer|`accel`|5
2|Bluetooth|`bluetoothLog`|3
3|Phone calls|`callLog`|4
4|GPS|`gps`|5
5|IDs|`identifiers`|4
6|Beiwe logs|`logFile`|1
7|Power State|`powerState`|2
8|Survey (1)|`surveyAnswers`|5
9|Survey (2)|`surveyTimings`|6
10|Text messages|`textsLog`|5
11|Voice memos|`voiceRecording`|NA
12|WiFi|`wifiLog`|3

## Timestamps
Each file prefix above is followed by `_[timestamp].csv`. The timestamp is Java time in UTC, which is milliseconds from epoch, and represents the *time of file creation*. Thus, note that this timestamp may differ from the timestamp you see online which represents the time of file upload. (**NOTE:** The app is designed to only upload when there is sufficient battery (or it is plugged in) and it is connected to WiFi.)

In order to use most conversion tools (which are designed for [Unix time](https://en.wikipedia.org/wiki/Unix_time) â€” i.e.,  seconds from epoch), simply perform integer division by 1000. For example, in `Python`, one must first perform `int(timestamp / 1000)` before using the `datetime` module to convert to human-readable time. In `Microsoft Excel` one might use a formula such as `=((timestamp/1000) / 86400) + 25569` and then convert the cell to datetime.

See [EpochConverter](http://www.epochconverter.com/) for more ways to manipulate Unix time into various programming languages.

## Accelerometer data
Accelerometer files contain 5 columns: `timestamp`, `accuracy`, `x`, `y`, and `z`.

**NOTE:** It is an open question about the bounds of the `x`, `y`, and `z`. In all our test data, the bounds are [-20, 20]; however, this may be specific to each handset and/or version of Android.

## Bluetooth
Bluetooth files contain: `timestamp`, `MAC`, and `RSSI`. Note that `MAC` is actually the *hashed* MAC address of other devices.

## Phone calls
Call logs contain: `hashed phone number`, `call type`, `date`, and `duration in seconds`. Note that `date` is the equivalent of `timestamp` in other files (i.e., it is not a human-readable datetime object). I have asked the programmers to fix this, but as of the most recent version, it has not been addressed.

## GPS
GPS files contain: `time`, `latitude`, `longitude`, `altitude`, and `accuracy`. Note that `time` here is the equivalent of `timestamp` in other places. Again, programmers may change this in future versions to be more consistent. Accuracy is the accuracy in meters.

## IDs
ID files should only contain one row and in most cases should one have one instance. A bug exists where this file may be created again, but I have not found a way to replicate the bug reliably. This file will contain the users own `patient id`, `(hashed) MAC`, `(hashed) phone_number`, and `device_id`.

**NOTE:** I'm assuming device ID is bluetooth MAC address, but am not sure. I'm also assuming hashed MAC is actually the phone's WiFi MAC address.

## Beiwe logs
Beiwe log files are app-generated messages and should be used only for diagnostic purposes. 

## Power State
Power logs have two columns: `time` and `event`. Note that `time` here is the equivalent of `timestamp` elsewhere. Power state events are things like `screen on`, `screen off`, `power connected` and `power disconnected`.

## Survey Answers
Variable depending on the survey.

## Survey Timings
Variable depending on the survey.

## Text messages
Text logs contain: `timestamp`, `hashed phone number`, `sent vs received`, `message length`, and `time sent`. In general, `time sent` should be ignored. It is theoretically the time the message was sent (from somebody else) while `timestamp` is the time that message would have been received by the user. In practice, these should be identical or very similar. 

## Voice memos
Self-recorded voice memos. Will vary by study.

## WiFi
Contains `hashed MAC`, `frequency`, and `RSSI`. Frequency will always be 2.4GHz or 5GHz so I'm not sure how useful that is.

# Known Data Issues
- The `textsLog` data often contain duplicates (usually 3 or 4 identical rows). This seems to be more common for sent texts but can occur for received texts. 

# Functions
More information about each function can be found in the function's docstring (i.e., `help([function])` or `?[function]`). This is just a list of functions to give you an idea of what has already been done.

- `row_count()` -- Iterates through a `csv` file and finds the number of observations
- `list_data_files()` -- Iterates through a user directory and looks for `csv` files that match a certain datastream (and time frame). For example, will find just accelerometer files or only survey files. (Note that this will **not** find voice recordings.)
- `list_audio_files()` -- Iterates through a user directory and looks for audio files (can filter out by time frame).
- `convert_mp4()` -- Audio files are saved as `mp4` in order to save space, but Python can only analyze `wav` files. Thus, this is a wrapped for `FFmpeg` to convert `mp4` files to `wav` files. **NOTE:** You must install `FFmpeg`.
- `return_file()` -- Takes a `csv` and returns a list of lists (i.e., a list containing sublists which are rows). The first item in the list is a list of header names.
- `make_timestamp()` -- A convenience wrapper function for specifying a date/time and returning a timestamp in UTC (in either Unix or Java time).
- `import_df()` -- Takes a list of files (created by `list_data_files()`) and turns them into a single `pandas` DataFrame. 
- `ts_to_local()` / `ts_to_utc()` -- Just convenience functions that will quickly turn a timestamp into local time or UTC in human-readable format.
- `plot_accel()` -- Takes an accelerometer dataframe (generated by `import_df()`) and returns a plot of the specified time interval.
- `plot_wav()` -- Takes a `wav` file (converted from `convert_mp4()` and plots the amplitude by time.
- `describe_user()` -- Looks through a user directory and provides quick summary information about that user's data. For example, number of files (by data stream) or number of observations, or empty files.
- `plot_gps()` -- Plots a GPS dataframe (generated by `import_df()`). Must have `basemap` installed.
- `duplicates()` -- Loops through a text message dataframe (generated by `import_df()`) and finds duplicated according to a "sliding window" rule. Use with caution. This is my solution, but is probably not good enough for people interested in truly understanding the communication network of these users.
- `rank_mac()` -- Takes a WiFi or Bluetooth dataframe and finds the top `n` MAC addresses for a specified aggregation level (default is 15 seconds).
- `_macs()` -- Takes a `rank_mac()`-generated dataframe and plots the instances of observations for each MAC throughout the specified timeline.
- `plot_n_macs()` -- Takes a WiFi or Bluetooth dataframe and plots the number of unique MAC addresses for a specified time aggregation level and also plots the cumulative distribution of MAC addresses.
- `plot_calls_texts()` -- Takes both a call and a text dataframe and roughly plots them.

# Example plots
All example code below assumes you've run the following import code:

```
import matplotlib
import matplotlib.pyplot as plt
import pandas as pd
from beiwedata import *
```

## Voice recordings
![Voice plot](https://github.com/onnela-lab/beiwedata/blob/master/example%20plots/voice_plot.png)

This plot was generated using `plot_wav()`.

```
## Get audio files
audio_files = list_audio_files(fpath='./user1', mp4only=True)

## Convert one to .wav
convert_mp4(audio_files[-1])

## Plot it
plot_wav(audio_files[-1][:-4] + '.wav', psave=True)
```

## Accelerometer plots
![Accel plot](https://github.com/onnela-lab/beiwedata/blob/master/example%20plots/accel_plot.png)

Plot was generated using `plot_accel()`.

```
acc_files = list_data_files(fpath='./user2', stream='accel')
df_accel = import_df(acc_files)

start = make_timestamp(2015, 5, 5, 23, 58)
end = make_timestamp(2015, 5, 7, 0, 2)

plot_accel(df_accel, start, end, psave=True)
```

## GPS plots
![GPS plot](https://github.com/onnela-lab/beiwedata/blob/master/example%20plots/gps_plot.png)

```
fgps = list_data_files(fpath='./user3', stream='gps')
dgps = import_df(fgps, tstamp='time')
dgps = dgps[dgps.accuracy < 75]

start = make_timestamp(2015, 5, 7, 14, 28)
end = make_timestamp(2015, 5, 7, 14, 33)

## This adds the roads to my map. Remove the shpfile parameter
## if you are actually running this code
fig = plot_gps(dgps, start, end,
               shpfile='./mydata/converted_MA_roads/converted_MA_roads',
               shpname='roads',
               sspacer=[.0002, .00065], dscale=True, slength=.2)
plt.show()
fig.set_size_inches(6, 6)
fig.savefig('gps_plot.pdf', bbox_inches='tight')
plt.close('all')
```

## Calls and texts plot
![Calls and texts](https://github.com/onnela-lab/beiwedata/blob/master/example%20plots/calls_and_texts.png)

```
cfiles = list_data_files(stream='call', fpath='user')
tfiles = list_data_files(stream='text', fpath='user')
tdf = import_df(tfiles)
cdf = import_df(cfiles)

fig, axes = plot_calls_texts(cdf, tdf, start_ts, end_ts)

axes.set_xlim([datetime.datetime(2015, 6, 22, 13),
               datetime.datetime(2015, 6, 22, 21)])

for label in axes.xaxis.get_ticklabels()[::2]:
    label.set_visible(False)

fig = plt.gcf()
fig.set_size_inches(12, 4)
fig.savefig('calls_and_texts.pdf', bbox_inches='tight')
```

## Bluetooth plots
![Bluetooth plots 1](https://github.com/onnela-lab/beiwedata/blob/master/example%20plots/bluetooth_top_devices.png)

```
bfiles = list_data_files(stream='blue', fpath='./mkdata')
bdf = import_df(bfiles)

start_ts = make_timestamp(2015, 5, 5, 23, 55)
end_ts = make_timestamp(2015, 5, 7, 0, 5)

freq_bt = rank_mac(bdf, start_ts, end_ts, n=10)
fig, axes = plot_most_macs(macdf = freq_bt)

axes.set_xlim([datetime.datetime(2015, 5, 5, 23, 55),
                datetime.datetime(2015, 5, 7, 0, 5)])
for label in axes.xaxis.get_ticklabels()[::2]:
    label.set_visible(False)
axes.set_title('Top Bluetooth Devices')
axes.set_ylabel('Unique Bluetooth Devices')
fig = plt.gcf()
fig.set_size_inches(12, 4)
fig.savefig('bluetooth_top_devices.png', bbox_inches='tight', dpi=150)
```
**NOTE:** See WiFi plots for variations of `_macs()`.

![Bluetooth plots 2](https://github.com/onnela-lab/beiwedata/blob/master/example%20plots/bluetooth_devices.png)

```
fig, axes = plot_n_macs(bdf, start_ts, end_ts)
axes[0].set_title('Bluetooth devices throughout the day')
for label in axes[1].xaxis.get_ticklabels()[1::2]:
    label.set_visible(False)
fig = plt.gcf()
fig.set_size_inches(12, 8)
fig.savefig('bluetooth_devices.png', bbox_inches='tight', dpi=150)
```

## WiFi plots
![Wifi plots 1](https://github.com/onnela-lab/beiwedata/blob/master/example%20plots/wifi_top_networks.png)

```
wfiles = list_data_files(stream='wifi', fpath='./mkdata')
wdf = import_df(wfiles)
start_ts = make_timestamp(2015, 5, 5, 23, 55)
end_ts = make_timestamp(2015, 5, 7, 0, 5)

freq_w = rank_mac(wdf, start_ts, end_ts, cname='hashed MAC', n=100)
fig, axes = plot_most_macs(macdf = freq_w, m='.')
axes.grid(False)
axes.set_title('Top WiFi Networks')
axes.set_ylabel('Unique WiFi Networks')
axes.set_ylim([0, 101])
for i, label in enumerate(axes.yaxis.get_ticklabels()):
    if (i % 10 != 0) and (i < len(axes.yaxis.get_ticklabels()) - 1):
        label.set_visible(False)
fig = plt.gcf()
fig.set_size_inches(18, 9)
fig.savefig('wifi_networks.png', bbox_inches='tight', dpi=150)
```

### With `strength` option

You may be interested in incorporating signal strength (`RSSI`) into these plots. Signal strength is highly variable by a number of external factors and it probably not something you want to plot the raw data for; however, `plot_most_macs()` does allow you to quickly plot percentiles of strength.

For example, assume we are the quartiles of signal strength, we just add `strength=4` to `plot_most_macs()`:
![Wifi plot with strength 4](https://github.com/onnela-lab/beiwedata/blob/mk-development/example%20plots/wifi_top_networks_strength4.png)

```
fig, axes = plot_most_macs(macdf = freq_w, m='.', strength=4)
axes.grid(False)
axes.set_title('Top WiFi Networks with Signal Strength')
axes.set_ylabel('Unique WiFi Networks')
axes.set_ylim([0, 101])
for i, label in enumerate(axes.yaxis.get_ticklabels()):
    if (i % 10 != 0) and (i < len(axes.yaxis.get_ticklabels()) - 1):
        label.set_visible(False)
fig = plt.gcf()
fig.set_size_inches(18, 9)
fig.savefig('wifi_top_networks_strength4.png', bbox_inches='tight', dpi=150)
```

This colors by quantiles so any arbitrary (integer) number is allowed. However, the colormapping has been cut off from [0, 1] to [.3, 1] since 0 (i.e., white) comes out looking too faint. Thus, for quantiles larger than about 5 or 6, differences become hard to see. Here is one with `strength=25`: 

![Wifi plot with strength 25](https://github.com/onnela-lab/beiwedata/blob/mk-development/example%20plots/wifi_top_networks_strength25.png)

### Wifi with `plot_others` option
We can also plot all others (that is, all devices not in ranking) by setting `plot_others=True`:

![Wifi plot with others](https://github.com/onnela-lab/beiwedata/blob/mk-development/example%20plots/wifi_top_networks_others.png?raw=true)

```
fig, axes = _macs(macdf = freq_w, m='.', plot_others=True)
axes.grid(False)
axes.set_title('Top WiFi Networks')
axes.set_ylabel('Unique WiFi Networks')
axes.set_ylim([-8, 101])
```
This should be considered a diagnostic convenience -- an easy way to tell if we are still collecting WiFi/Bluetooth data. However, note that this information is redundant with `plot_n_macs()`.

### Wifi with `plot_others` and `strength`
And obviously you can combine both `plot_others=True` with `strength` together:

![Wifi plot with strength and others](https://github.com/onnela-lab/beiwedata/blob/mk-development/example%20plots/wifi_top_networks_strength4_others.png)

```
fig, axes = plot_most_macs(macdf = freq_w, m='.', strength=4,
                           plot_others=True)
axes.grid(False)
axes.set_title('Top WiFi Networks')
axes.set_ylabel('Unique WiFi Networks')
fig = plt.gcf()
fig.set_size_inches(18, 9)
fig.savefig('wifi_top_networks_strength4_others.png', bbox_inches='tight',
            dpi=150)
```


![Wifi plots 2](https://github.com/onnela-lab/beiwedata/blob/master/example%20plots/wifi_networks.png)

```
fig, axes = plot_n_macs(wdf, start_ts, end_ts, cname='hashed MAC')
axes[0].set_title('Wifi networks throughout the day')
fig = plt.gcf()
fig.set_size_inches(12, 8)
fig.savefig('wifi_networks.png', bbox_inches='tight', dpi=150)
```
