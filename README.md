# Introduction
`beiwe-desktop` is a set of Python scripts designed to help munge, analyze, and manipulate data generated by the Beiwe application. 

# Table of Contents
- [Usage](#usage)
- [Data overview](#data-overview)
    - [Timestamps](#timestamps)

# Usage
`from beiwe-desktop import *` is the standard way to import and this document will assume `beiwe-desktop` has been imported to the top level. If you `import as`, please adjust the usage examples accordingly.

# Data overview
There are a total of 12 types of files generated by the `beiwe` app. Files are stored as comma-separated values (`csv`) files and **every** file contains column headers (including empty files). Empty files are created when the application is activated and data is being collected, but there is no data to collect. For example, during a "WiFi" check the application will activate, check for WiFi signals, and record them. During this time, it may also check to see if there is any new Bluetooth or call/text information to gather. If no new information exists, it will create the file with the headers, but no other rows.

\#|Data stream|File prefix|\# Col
:-:|-----------|-----------|:---:
1|Accelerometer|`accel`|5
2|Bluetooth|`bluetoothLog`|3
3|Phone calls|`callLog`|4
4|GPS|`gps`|5
5|IDs|`identifiers`|4
6|Beiwe logs|`logFile`|1
7|Power State|`powerState`|2
8|Survey (1)|`surveyAnswers`|5
9|Survey (2)|`surveyTimings`|6
10|Text messages|`textsLog`|5
11|Voice memos|`voiceRecording`|NA
12|WiFi|`wifiLog`|3

## Timestamps
Each file prefix above is followed by `_[timestamp].csv`. The timestamp is Java time in UTC, which is microseconds from epoch, and represents the *time of file creation*. Thus, note that this timestamp may differ from the timestamp you see online which represents the time of file upload. (**NOTE:** The app is designed to only upload when there is sufficient battery (or it is plugged in) and it is connected to WiFi.)

In order to use most conversion tools (which are designed for [Unix time](https://en.wikipedia.org/wiki/Unix_time)), simply perform integer division by 1000. For example, in `Python`, one must first perform `int(timestamp / 1000)` before using the `datetime` module to convert to human-readable time. In `Microsoft Excel` one might use a formula such as `=((timestamp/1000) / 86400) + 25569` and then convert the cell to datetime.

See [EpochConverter](http://www.epochconverter.com/) for more ways to manipulate Unix time into various programming languages.

## Accelerometer data
Accelerometer files contain 5 columns: `timestamp`, `accuracy`, `x`, `y`, and `z`.

**NOTE:** It is an open question about the bounds of the `x`, `y`, and `z`. In all our test data, the bounds are [-20, 20]; however, this may be specific to each handset and/or version of Android.

## Bluetooth
Bluetooth files contain: `timestamp`, `MAC`, and `RSSI`. Note that `MAC` is actually the *hashed* MAC address of other devices.

## Phone calls
Call logs contain: `hashed phone number`, `call type`, `date`, and `duration in seconds`. Note that `date` is the equivalent of `timestamp` in other files (i.e., it is not a human-readable datetime object). I have asked the programmers to fix this, but as of the most recent version, it has not been addressed.

## GPS
GPS files contain: `time`, `latitude`, `longitude`, `altitude`, and `accuracy`. Note that `time` here is the equivalent of `timestamp` in other places. Again, programmers may change this in future versions to be more consistent. Accuracy is the accuracy in meters.

## IDs
ID files should only contain one row and in most cases should one have one instance. A bug exists where this file may be created again, but I have not found a way to replicate the bug reliably. This file will contain the users own `patient id`, `(hashed) MAC`, `(hashed) phone_number`, and `device_id`.

**NOTE: I'm assuming device ID is bluetooth MAC address, but am not sure. I'm also assuming hashed MAC is actually the phone's WiFi MAC address.

## Beiwe logs
Beiwe log files are app-generated messages and should be used only for diagnostic purposes. 

## Power State
Power logs have two columns: `time` and `event`. Note that `time` here is the equivalent of `timestamp` elsewhere. Power state events are things like `screen on`, `screen off`, `power connected` and `power disconnected`.

## Survey Answers
Variable depending on the survey.

## Survey Timings
Variable depending on the survey.

## Text messages
Text logs contain: `timestamp`, `hashed phone number`, `sent vs received`, `message length`, and `time sent`. In general, `time sent` should be ignored. It is theoretically the time the message was sent (from somebody else) while `timestamp` is the time that message would have been received by the user. In practice, these should be identical or very similar. 

## Voice memos
Self-recorded voice memos. Will vary by study.

## WiFi
Contains `hashed MAC`, `frequency`, and `RSSI`. Frequency will always be 2.4GHz or 5GHz so I'm not sure how useful that is.

# Functions
More information about each function can be found in the function's docstring (i.e., `help([function])` or `?[function]`). This is just a list of functions to give you an idea of what has already been done.

- `row_count()` -- Iterates through a `csv` file and finds the number of observations
- `list_data_files()` -- Iterates through a user directory and looks for `csv` files that match a certain datastream (and time frame). For example, will find just accelerometer files or only survey files. (Note that this will **not** find voice recordings.)
- `list_audio_files()` -- Iterates through a user directory and looks for audio files (can filter out by time frame).
- `convert_mp4()` -- Audio files are saved as `mp4` in order to save space, but Python can only analyze `wav` files. Thus, this is a wrapped for `FFmpeg` to convert `mp4` files to `wav` files. **NOTE:** You must install `FFmpeg`.
- `return_file()` -- Takes a `csv` and returns a list of lists (i.e., a list containing sublists which are rows). The first item in the list is a list of header names.
- `make_timestamp()` -- A convenience wrapper function for specifying a date/time and returning a timestamp in UTC (in either Unix or Java time).
- `import_df()` -- Takes a list of files (created by `list_data_files()`) and turns them into a single `pandas` DataFrame. 
- `ts_to_local()` / `ts_to_utc()` -- Just convenience functions that will quickly turn a timestamp into local time or UTC in human-readable format.
- `plot_accel()` -- Takes an accelerometer dataframe (generated by `import_df()`) and returns a plot of the specified time interval.
- `plot_wav()` -- Takes a `wav` file (converted from `convert_mp4()` and plots the amplitude by time.
- `describe_user()` -- Looks through a user directory and provides quick summary information about that user's data. For example, number of files (by data stream) or number of observations, or empty files.
- `plot_gps()` -- Plots a GPS dataframe (generated by `import_df()`). Must have `basemap` installed.
- `duplicates()` -- Loops through a text message dataframe (generated by `import_df()`) and finds duplicated according to a "sliding window" rule. Use with caution. This is my solution, but is probably not good enough for people interested in truly understanding the communication network of these users.
